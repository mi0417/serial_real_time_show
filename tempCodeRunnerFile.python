import unittest
from unittest.mock import MagicMock
from controller import SerialController, SerialModel, ReceiveThread

class TestSerialController(unittest.TestCase):
    def setUp(self):
        self.title = "Test Title"
        self.myappid = "Test App ID"
        self.icon_path = "Test Icon Path"
        self.controller = SerialController(self.title, self.myappid, self.icon_path)

    def test_handle_serial_data_received(self):
        # 模拟串口索引和数据
        index = 1
        data = b"Mocked Serial Data"

        # 模拟日志记录
        self.controller.view.log_message = MagicMock()
        self.controller.handle_serial_data_received(index, data)

        # 断言日志记录是否正确
        self.controller.view.log_message.assert_called_once_with(f'Received data from serial {index}: {data}')

    def test_check_serial_data(self):
        # 模拟串口打开状态和最后接收时间
        self.controller.model.is_serial_open = MagicMock(return_value=True)
        self.controller.model.last_receive_time = [0] * 6
        self.controller.model.last_receive_time[0] = 1600000000  # 假设的时间戳

        # 模拟当前时间
        import time
        time.time = MagicMock(return_value=1600000001)

        # 模拟设置 LED 状态
        self.controller.view.set_led = MagicMock()

        # 调用检查方法
        self.controller.check_serial_data()

        # 断言 LED 状态是否正确设置
        self.controller.view.set_led.assert_called_with(1, True)

    def test_handle_combobox_change_open_serial(self):
        # 模拟组合框选择
        combobox_index = 1
        port_name = "COM1"
        baudrate = 9600
        timeout = 1

        # 模拟打开串口线程
        OpenSerialThread = MagicMock()
        self.controller.OpenSerialThread = OpenSerialThread

        # 模拟日志记录
        self.controller.view.log_message = MagicMock()

        # 调用组合框选择变化处理方法
        self.controller.handle_combobox_change(combobox_index, port_name)

        # 断言线程是否正确创建和启动
        OpenSerialThread.assert_called_once_with(self.controller.model, combobox_index, port_name, baudrate, timeout)
        OpenSerialThread().start.assert_called_once()

    def test_handle_combobox_change_close_serial(self):
        # 模拟组合框选择
        combobox_index = 1
        port_name = "close"

        # 模拟串口打开状态
        self.controller.model.is_serial_open = MagicMock(return_value=True)

        # 模拟日志记录
        self.controller.view.log_message = MagicMock()

        # 模拟关闭串口
        self.controller.model.close_serial_port = MagicMock()
        self.controller.view.change_portlabel_color = MagicMock()

        # 模拟接收线程
        self.controller.receive_threads[combobox_index - 1] = MagicMock()

        # 调用组合框选择变化处理方法
        self.controller.handle_combobox_change(combobox_index, port_name)

        # 断言串口是否正确关闭
        self.controller.model.close_serial_port.assert_called_once_with(combobox_index)
        self.controller.view.change_portlabel_color.assert_called_once_with(combobox_index, False)
        self.controller.receive_threads[combobox_index - 1].stop.assert_called_once()
        self.controller.receive_threads[combobox_index - 1].wait.assert_called_once()


if __name__ == '__main__':
    unittest.main()